<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><meta content="width=device-width; initial-scale=1.0" name="viewport" /><title>Ruby女孩(29)：揭開區塊的面紗-Proc、lambda</title><meta content="Ruby女孩(29)：揭開區塊的面紗-Proc、lambda" name="title" /><meta content="Ruby女孩(29)：揭開區塊的面紗-Proc、lambda" property="og:title" /><meta content="Ruby女孩(29)：揭開區塊的面紗-Proc、lambda" name="twitter:title" /><meta content="http://annideas.tw/ironman/2014-10-29-ruby-girl-29-ruby-proc-lambda/" name="url" /><meta content="http://annideas.tw/ironman/2014-10-29-ruby-girl-29-ruby-proc-lambda/" property="og:url" /><meta content="參加連續30天寫文章的技術鐵人賽，我選擇讀一本『The Ruby Programming Language』，整理在書中所吸取的知識，試著以不斷詢問為什麼的方式，追根究底的讀通 Ruby 語言的基礎。" name="description" /><meta content="參加連續30天寫文章的技術鐵人賽，我選擇讀一本『The Ruby Programming Language』，整理在書中所吸取的知識，試著以不斷詢問為什麼的方式，追根究底的讀通 Ruby 語言的基礎。" property="og:description" /><meta content="參加連續30天寫文章的技術鐵人賽，我選擇讀一本『The Ruby Programming Language』，整理在書中所吸取的知識，試著以不斷詢問為什麼的方式，追根究底的讀通 Ruby 語言的基礎。" itemprop="description" /><meta content="參加連續30天寫文章的技術鐵人賽，我選擇讀一本『The Ruby Programming Language』，整理在書中所吸取的知識，試著以不斷詢問為什麼的方式，追根究底的讀通 Ruby 語言的基礎。" name="twitter:description" /><meta content="2014-10-29 08:58 UTC" property="article:published_time" /><meta content="https://www.facebook.com/OtiAnn" property="article:author" /><meta content="article" name="type" /><meta content="article" property="og:type" /><meta content="838413066169349" property="fb:app_id" /><meta content="zh_TW" property="og:locale" /><meta content="Annideas?" itemprop="name" /><meta content="Annideas?" property="og:site_name" /><meta content="http://annideas.tw/images/annie_pic.jpg" property="og:image" /><meta content="@_OtiAnn" name="twitter:site" /><meta content="summary_large_image" name="twitter:card" /><meta content="http://annideas.tw/images/annie_pic.jpg" name="twitter:image" /><meta content="@_OtiAnn" name="twitter:creator" /><meta content="wj4kHYLvvEKT7b_B7Fqp56gRY77ipGuhg11O--1EKXw" name="google-site-verification" /><link href="/stylesheets/application-c5790129.css" rel="stylesheet" /><script src="/javascripts/jquery-3.2.1.min-aa407c6a.js"></script><script src="/javascripts/application-fb8733fc.js"></script><link href="/images/icon-f0edf780.png" rel="shortcut icon" /></head><body class="ironman ironman_2014-10-29-ruby-girl-29-ruby-proc-lambda ironman_2014-10-29-ruby-girl-29-ruby-proc-lambda_index"><div class="wrapper"><a href="/" class="go_home_logo"><img src="/images/go_home_logo-55ba1e01.png" alt="Go home logo" /><h1 class="title">Annideas?</h1></a><div class="container"><div class="articleContent"><div class="articleContent-category"><a href="/ironman7">鐵 人</a></div><div class="articleContent-title">Ruby女孩(29)：揭開區塊的面紗-Proc、lambda</div><div class="articleContent-date">2014．Oct．29</div><div class="articleContent-article tp-in-content"><p>昨天解謎解到一半，發現區塊的類別是<code>Proc</code>。啥？什麼是<code>Proc</code>？其實昨天提到的區塊，實際上它並不是物件！不能直接像物件那樣被操作。
所以該如何操作區塊呢？今天就來談談這個部分。先來看看書中一段：</p>

<blockquote>
  <p>『我們可以建立一個代表區塊的物件，依據物件建立方式的不同，它可以被稱為一個proc或一個lambda。proc的行為如同區塊，而lambda的行為如同方法。然而，他們都是Proc類別的實例。』(p.198)</p>
</blockquote>

<h2 id="proclambda">proc與lambda</h2>

<h3 id="proc">建立proc</h3>

<p>(1)第一種建立proc的方式：透過調用方法來建立proc</p>

<div class="highlight"><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">makeproc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iamproc</span><span class="p">)</span>  
  <span class="n">iamproc</span>  
<span class="k">end</span>  
</code></pre></div>
<p>上面的方法看起來就像昨天區塊引數的介紹，當我們在引數前綴一個<strong>『&amp;』</strong>時，我們已經將所伴隨的區塊轉換成一個<strong>Proc物件</strong>並存入<code>iamproc</code>中，另外在方法中再傳回Proc物件。</p>

<p>此時我們可以利用<code>makeproc</code>這個方法來建立Proc物件：</p>

<div class="highlight"><pre class="highlight ruby"><code><span class="n">aa</span> <span class="o">=</span> <span class="n">makeproc</span><span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="p">}</span>  
<span class="o">=&gt;</span> <span class="c1">#&lt;Proc:0x007fe6a5929cb0@(irb):43&gt;  </span>

<span class="n">bb</span> <span class="o">=</span> <span class="n">makeproc</span><span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">+</span><span class="n">x</span> <span class="p">}</span>  
<span class="o">=&gt;</span> <span class="c1">#&lt;Proc:0x007fe6a59b8730@(irb):44&gt;  </span>
</code></pre></div>
<p>所有的Proc物件都具有<code>.call</code>這個方法，當它被調用時，會執行區塊中的程式碼：</p>

<div class="highlight"><pre class="highlight ruby"><code><span class="n">aa</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  
<span class="o">=&gt;</span> <span class="mi">25</span>  
<span class="n">bb</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  
<span class="o">=&gt;</span> <span class="mi">6</span>  
</code></pre></div>
<p>(2)Proc.new</p>

<div class="highlight"><pre class="highlight ruby"><code><span class="n">aa</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span><span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="p">}</span>  
<span class="o">=&gt;</span> <span class="c1">#&lt;Proc:0x007fcb1d239de0@(irb):1&gt;  </span>
</code></pre></div>
<p>這個建立Proc實體的方式，是所有方式中最明顯的，其實下面這兩種寫法是完全等效的，大家可以比較看看：</p>

<div class="highlight"><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>  
  <span class="n">block</span><span class="p">.</span><span class="nf">call</span>  
<span class="k">end</span>  
</code></pre></div>
<p>與</p>

<div class="highlight"><pre class="highlight plaintext"><code>def test  
  Proc.new.call  
end  
</code></pre></div>
<p>(3)Kernel.lambda</p>

<div class="highlight"><pre class="highlight ruby"><code><span class="n">bb</span> <span class="o">=</span> <span class="nb">lambda</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">+</span><span class="n">x</span><span class="p">}</span>  
<span class="o">=&gt;</span> <span class="c1">#&lt;Proc:0x007fcb1e0b52c0@(irb):2 (lambda)&gt;  </span>
  
<span class="n">bb</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  
<span class="o">=&gt;</span> <span class="mi">6</span>  
</code></pre></div>
<p>在文章一開始，有節錄書中一段話，指出Proc類別下有proc與lambda之分別，剛剛前兩種建立Proc物件的方法都是建立出Proc下的proc，而第三種則很明顯，是建立出Proc下的lambda，至於proc與lambda到底差在哪裡，我們隨後介紹完建立方法會解釋。</p>

<p>(4)Kernel.proc</p>

<p>這裡所指的proc與上面的lambda都屬於Kernel模組的方法，他們都是全域方法。</p>

<div class="highlight"><pre class="highlight ruby"><code><span class="n">cc</span> <span class="o">=</span> <span class="nb">proc</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">+</span><span class="n">x</span><span class="p">}</span>  
<span class="o">=&gt;</span> <span class="c1">#&lt;Proc:0x007fcb1c017f18@(irb):5&gt;  </span>
<span class="n">cc</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  
<span class="o">=&gt;</span> <span class="mi">10</span>  
</code></pre></div>
<p>Ruby1.8以前proc都只是lambda的同義字，不過Ruby1.9之後，proc其實是Proc.new的縮寫。</p>

<h3 id="proclambda-1">調用proc或lambda</h3>

<p>除了call這個方法可以傳遞引數給區塊之外，也可使用中括號：</p>

<div class="highlight"><pre class="highlight ruby"><code><span class="n">cc</span> <span class="o">=</span> <span class="nb">proc</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">|</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">}</span>  
<span class="n">cc</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>  
<span class="o">=&gt;</span> <span class="mi">13</span>  
  
<span class="n">dd</span> <span class="o">=</span> <span class="nb">lambda</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">|</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">}</span>  
<span class="n">dd</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>  
<span class="o">=&gt;</span> <span class="mi">56</span>  
</code></pre></div>
<h3 id="lambdaproc">lambda與proc有何差別</h3>

<blockquote>
  <p>『proc是一個區塊的物件形式，行為就如同一個區塊；lambda的行為稍有不同，叫像一個方法而非區塊。』(p.203)</p>
</blockquote>

<div class="highlight"><pre class="highlight ruby"><code><span class="n">dd</span><span class="p">.</span><span class="nf">proc?</span>  
<span class="no">NoMethodError</span><span class="p">:</span> <span class="n">undefined</span> <span class="nb">method</span> <span class="sb">`proc?' for #&lt;Proc:0x007fcb1cbe1f88@(irb):8 (lambda)&gt;  
  
dd.lambda?  
=&gt; true  
</span></code></pre></div>
<p>上方所示，<code>lambda?</code>因為如同一個方法，我們可以用來確定Proc物件是不是proc或lambda，但我們只有<code>lambda?</code>而不會有<code>proc?</code>這個方法。</p>

<p>另外也有人說lamnda就是比較嚴謹的proc，傳入的參數不足，是會噴錯的，例如：</p>

<div class="highlight"><pre class="highlight ruby"><code><span class="n">aa</span> <span class="o">=</span> <span class="nb">proc</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">x</span> <span class="p">;</span> <span class="nb">puts</span> <span class="n">y</span><span class="p">}</span>  
<span class="o">=&gt;</span> <span class="c1">#&lt;Proc:0x007fb3c4ae21d8@(irb):1&gt;  </span>
  
<span class="n">bb</span> <span class="o">=</span> <span class="nb">lambda</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">x</span> <span class="p">;</span> <span class="nb">puts</span> <span class="n">y</span><span class="p">}</span>  
<span class="o">=&gt;</span> <span class="c1">#&lt;Proc:0x007fb3c330f8f8@(irb):2 (lambda)&gt;  </span>
  
<span class="n">aa</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>  
<span class="mi">3</span>  
<span class="mi">4</span>  
  
<span class="n">bb</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>  
<span class="mi">3</span>  
<span class="mi">4</span>  
  
<span class="n">aa</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  
<span class="mi">3</span>  
  
  
<span class="n">bb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  
<span class="no">ArgumentError</span><span class="p">:</span> <span class="n">wrong</span> <span class="n">number</span> <span class="n">of</span> <span class="n">arguments</span> <span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="mi">2</span><span class="p">)</span>  
</code></pre></div>
<p>其實寫到這裡，對於proc和lambda實作性還是不太清楚，有關proc與lambda之間的內容，網路上也有很多人做過分析，大家有興趣也可以多看看：</p>

<ul>
  <li><a href="http://tonytonyjan.net/2011/08/12/ruby-block-proc-lambda/">Ruby Block, Proc and Lambda</a></li>
  <li><a href="http://openhome.cc/Gossip/Ruby/Proc.html">Ruby Gossip: 程式區塊與 Proc</a></li>
  <li><a href="http://brian-p-pan-blog.logdown.com/posts/195007-ruby-block">[Ruby] Block &amp; Proc/Lambda</a></li>
  <li><a href="http://chuyi.inow.tw/index.php/ruby%E7%9A%84block-lambda-proc%E8%88%87%E5%87%BD%E5%BC%8F%E7%89%A9%E4%BB%B6/">Ruby的block, lambda, Proc與函式物件</a></li>
</ul>

<hr />

<p>29天！</p>

<blockquote>
  <p>“It is never too late to be what you might have been.” George Eliot</p>
</blockquote>

<p>只要開始，永遠不嫌晚，快加入Ruby 的行列吧XD</p>
</div><div class="articleContent-social"><div id="fb-root"></div><script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = 'https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v3.1&appId=838413066169349&autoLogAppEvents=1';
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script><div class="fb-like" data-action="like" data-href="http://annideas.tw/ironman/2014-10-29-ruby-girl-29-ruby-proc-lambda/" data-layout="button_count" data-share="true" data-show-faces="true" data-size="small" data-width="700px"></div></div><div class="articleContent-paging"><a href="../2014-10-30-ruby-girl-30-ruby-learning-outline/" class="articleContent-paging-item articleContent-paging-item--prev"><div class="articleContent-paging-item-title single-dot">Ruby女孩(30)：想學Ruby嗎？來聞香吧！</div><div class="articleContent-paging-item-date">2014．Oct．30</div></a><a href="../2014-10-28-ruby-girl-28-ruby-block/" class="articleContent-paging-item articleContent-paging-item--next"><div class="articleContent-paging-item-title single-dot">Ruby女孩(28)：慢慢打開區塊引數的包裝</div><div class="articleContent-paging-item-date">2014．Oct．28</div></a></div><div id="disqus_thread"></div>
<script type="text/javascript">
//<![CDATA[
                  var disqus_shortname = 'otiannie5';
          
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
//]]>
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div></div><div class="menu_icon_block" data-show-menu=""><div class="menu_icon"></div></div><div class="mask" data-hide-menu=""></div><nav><img class="close" data-hide-menu="true" src="/images/cross-e391fcc8.svg" alt="Cross" /><div class="avatar"><a href="/"><img src="/images/annie_pic-a20039dc.jpg" alt="Annie pic" /></a></div><div class="social_link"><a href="/en/resume"><img class="resume" src="/images/me-123f788f.svg" alt="Me" /></a><a href="https://twitter.com/YCCAnnie" target="_blank"><img class="twitter" src="/images/twitter-e0f1f272.svg" alt="Twitter" /></a><a href="https://www.linkedin.com/in/yccannie" target="_blank"><img class="linkedin" src="/images/linkedin-2ba621d9.svg" alt="Linkedin" /></a></div><div class="desc_block"><div class="name">Yu-Chen (Annie) Chen</div><div class="description">1 year Data Engineer, 2+ years Web Developer, 7+ years Instructor</div></div><ul class="catgory_list"><li><a href="/categories/生活/" class="life">Life (4)</a></li><li><a href="/categories/學習/" class="edu">Learning (4)</a></li><li><a href="/categories/開發/" class="dev">Coding (7)</a></li><li><a href="/ironman7">Article (30)</a></li><li class="practice_link"><a href="/practice">Practice (1)<img class="pacman" src="/images/pacman-43d7b83d.svg" alt="Pacman" /></a></li></ul></nav><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-51807616-2', 'auto');
ga('send', 'pageview');</script></div></body></html>